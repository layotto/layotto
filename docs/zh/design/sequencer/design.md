# Sequencer API设计文档
本文档讨论"生成分布式唯一(自增)id"的API

## 1. 需求
### 1.1. 生成全局唯一id

Q: 什么时候需要生成全局唯一id?

A: db不帮你自动生成的时候。比如：
- db做了分库分表，没帮你自动生成id，你又需要一个全局唯一的业务id
- 没走db，比如请求到了后端要生成一个traceId

### 1.2. 对该id有递增的需求。具体来说有很多种：
- 不需要递增。这种情况UUID能解决，虽然缺点是比较长。**本API暂时不考虑这种情况**
- “趋势递增”。不追求一定递增，大部分情况在递增就行。

Q: 什么场景需要趋势递增？

A: 对b+树类的db来说cache friendly。不过这种场景其实没有全局趋势递增需求，可以分表递增，用不到全局趋势递增;

拿来排序查最新数据。比如查最新消息时，不想新增个时间戳字段、建索引，想直接按id排序查最新的100条：
```
select * from message order by message-id limit 100
```
再比如nosql之类的在时间戳字段上加索引很难，分页查最新数据的时候，只想按id查

- sharding内单调递增。比如[Tidb的自增id](https://docs.pingcap.com/zh/tidb/stable/auto-increment) 能保证单台服务器上生成的id递增，没法保证全局（在多台服务器上）单调递增
- 全局单调递增

### 1.3. 可能会有自定义id schema的需求
比如要求id的格式为"前8位是uid，后8位是自增id"这样的需求

### 1.4. 可能有信息安全相关需求
如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；

如果是订单号就更危险了，竞对可以直接知道用户一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。

## 2. 产品调研
| **系统** | **能否保证生成的id唯一** | **趋势递增** | **严格递增** |  **可用性** | **信息安全**
| --- | --- | --- | --- |  --- |  --- |
| 单机redis | yes.[需要特殊配置redis服务器，把两种落盘策略都打开、每次写操作都写磁盘](https://redis.io/topics/persistence) ，避免丢数据  | yes | yes.前提是宕机重启不丢数据 | 有单点故障风险  |
| redis 主从复制+sentinel | no.复制是异步的，即使用Wait命令等待同步复制还是可能在fo后丢数据,见[文档](https://redis.io/topics/replication) | yes | 取决于会不会丢数据 |   |
| redis cluster | 同上 | yes | 同上 |   |
| snowflake | no.(时钟回拨等情况可能导致id重复；需要依赖外部存储；或者声明必须关闭NTP或使用防止回拨的可靠NTP) | yes | no |   | good |
| Leaf snowflake | yes | yes | no |     | good |
| Leaf segment | yes | yes | no |     |
| Leaf segment只部署一台Leaf服务器 | yes | yes | yes | 有单点故障风险  |
| zookeeper | yes | yes | yes |  |
| etcd | yes | yes | yes |  |
| mysql单库单表 | yes | yes | yes | 有单点故障风险 |


## 3. grpc API设计
### 3.1. proto定义
```protobuf
// Sequencer API
rpc GetNextId(GetNextIdRequest )returns (GetNextIdResponse) {}


message GetNextIdRequest {
  string store_name = 1;
  // key is the identifier of a sequencer.
  string key = 2;
  
  SequencerOptions options = 3;
  // The metadata which will be sent to the component.
  map<string, string> metadata = 4;
}

// SequencerOptions configures requirements for incremental and uniqueness guarantee
message SequencerOptions {  
  enum AutoIncrement {
    // WEAK means a "best effort" incrementing service.But there is no strict guarantee   
    WEAK = 0;
    // STRONG means a strict guarantee of global monotonically increasing
    STRONG = 1;
  }
  
//  enum Uniqueness{
//    // WEAK means a "best effort" unqueness guarantee.
//    // But it might duplicate in some corner cases.
//    WEAK = 0;
//    // STRONG means a strict guarantee of global uniqueness
//    STRONG = 1;
//  }

  AutoIncrement increment = 1;
//  Uniqueness uniqueness=2;
}

message GetNextIdResponse{
  int64 next_id=1;
}
```

解释：

其实就一个GetNextId接口，需要传key作为命名空间（比如传某个订单表表名，"order_table"），sequencer保证生成的id在该命名空间内唯一、递增。

SequencerOptions.AutoIncrement用于声明用户对递增性的需求，是趋势递增(WEAK)还是要求严格全局递增(STRONG)

**Q: 是否由Layotto帮用户按需拼id？**

A: API和Layotto运行时不管这事，由sdk或者用户自己处理，或者某个特殊组件想实现这个feature也可以。

**Q: 返回类型是string还是int64**

如果返回string，假如用户用了某个返回int64的实现，在用户代码中把返回的string转成了int64,那他迁移到别的组件，这个转换过程可能报错

如果返回int64，组件就没法帮用户做一些定制拼id的事情了

为了可移植性，选择int64。拼id的事情在sdk里做

**Q: int64溢出问题怎么处理?**

暂不考虑

### 3.2. 关于唯一性的争议
API中原先定义了用户传参SequencerOptions.Uniqueness枚举值 ,其中WEAK代表"尽量保证全局唯一，但是极小概率可能重复"，要求业务代码如果拿到id去写库时，做好id重复、重试的心理准备；而STRONG代表严格全局唯一，用户代码不考虑id重复、重试之类的事情。

- 定义这个枚举值的原因（好处）

如果要保证严格唯一，组件实现起来会比较重。比如单机redis常用的落盘策略就不行，可能导致宕机重启之后丢数据、生成一个重复id；比如直接在sidecar里写一个snowflake算法就不行，因为可能会有时钟回拨导致id重复的问题（NTP时钟同步、闰秒等情况都有可能导致时钟回拨）。[Leaf的snowflake实现](https://tech.meituan.com/2017/04/21/mt-leaf.html) 依赖zookeeper判断时钟回拨；

- 定义这个枚举值的缺点

给用户带来更多理解成本

- 结论

存在争议，本期先不添加该枚举值。默认返回的结果一定能保证全局唯一(STRONG)。

## 4. 组件API
```go
package sequencer

type Store interface {
	// Init this component.
	//
	// The number 'BiggerThan' means that the id generated by this component must be bigger than this number.
	//
	// If the component find that currently the storage can't guarantee this,
	// it can do some initialization like inserting a new id equal to or bigger than this 'BiggerThan' into the storage,
	// or just return an error
	Init(metadata Configuration) error

	GetNextId(*GetNextIdRequest) (*GetNextIdResponse, error)

	// GetSegment returns a range of id.
	// 'support' indicates whether this method is supported by the component.
	// Layotto runtime will cache the result if this method is supported.
	GetSegment(*GetSegmentRequest) (support bool, result *GetSegmentResponse, err error)
}

type GetNextIdRequest struct {
	Key      string
	Options  SequencerOptions
	Metadata map[string]string
}

type SequencerOptions struct {
	AutoIncrement AutoIncrementOption
}

type AutoIncrementOption string

const (
	WEAK   AutoIncrementOption = "weak"
	STRONG AutoIncrementOption = "strong"
)

type GetNextIdResponse struct {
	NextId int64
}

type GetSegmentRequest struct {
	Size     int
	Key      string
	Options  SequencerOptions
	Metadata map[string]string
}

type GetSegmentResponse struct {
	Segment []int64
}

type Configuration struct {
	BiggerThan int64             `json:"bigger_than"`
	Properties map[string]string `json:"properties"`
}

```

**Q: 要不要在runtime层实现缓存?**

如果runtime做缓存，需要组件实现方法：
```go
GetSegment(*GetSegmentRequest) (support bool, result *GetSegmentResponse, err error)
```

可以先定义接口，组件先不实现，以后有性能需求再实现

## 参考资料
[设计分布式唯一id生成](https://www.jianshu.com/p/fb9478687e55)

[架构 细聊分布式ID生成方法](https://www.w3cschool.cn/architectroad/architectroad-distributed-id.html)

[Leaf——美团点评分布式ID生成系统](https://tech.meituan.com/2017/04/21/mt-leaf.html)