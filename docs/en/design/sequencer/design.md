# Sequencer API Design Document

This document discusses the API for generating distributed unique (incremental) IDs.

## 1. Requirements
### 1.1. Generating globally unique IDs

Q: When do we need to generate globally unique IDs?

A: When the database does not automatically generate them. For example:
- When the database is sharded, and it does not generate IDs automatically, and you need a globally unique business ID.
- When there is no database involved, such as when you need to generate a trace ID in the backend.

### 1.2. The IDs should have an incremental requirement. Specifically, there are many types of requirements:
- No incremental requirement. UUID can solve this problem, although it is relatively long. **This API does not currently consider this situation.**
- "Trend incremental". There is no strict requirement for incremental values, but in most cases, they should be incremental.

Q: When do we need trend incremental IDs?

1. For databases like B+ trees (such as MYSQL), trend incremental primary keys can make better use of caches (cache-friendly).

2. Used for sorting and querying the latest data. For example, if you need to query the latest 100 messages, and the developer does not want to add a timestamp field or create an index, if the IDs themselves are incremental, you can simply sort by ID when querying the latest 100 messages:

```
select * from message order by message-id limit 100
```

This is common when using NoSQL, because it is difficult to add an index to a timestamp field.

- Monotonically increasing within a sharding. For example, [Tidb's auto-increment ID](https://docs.pingcap.com/zh/tidb/stable/auto-increment) can guarantee that the IDs generated on a single server are monotonically increasing, but it cannot guarantee that they are monotonically increasing globally (on multiple servers).

- Globally monotonically increasing

The generated IDs should be strictly incremental, with no backward movement.

### 1.3. There may be a need for custom ID schemas
For example, the ID format may need to be "the first 8 digits are the UID, and the last 8 digits are the incremental ID".

### 1.4. There may be information security-related requirements
If the ID is consecutive, malicious users can easily scrape data by directly downloading the specified URL in order. If it is an order number, it is even more dangerous as competitors can directly know the user's daily order volume. Therefore, in some application scenarios, IDs need to be irregular and non-sequential.

## 2. Product Research
| **System** | **Can it guarantee unique ID generation?** | **Trend Increment** | **Strict Increment** | **Availability** | **Information Security**
| --- | --- | --- | --- |  --- |  --- |
| Standalone Redis | Yes. [Special Redis server configuration is required, with both persistence strategies enabled and each write operation written to disk](https://redis.io/topics/persistence) to avoid data loss | Yes | Yes. Provided that no data is lost during server restart | There is a risk of single point of failure |
| Redis Master-Slave Replication + Sentinel | No. Replication is asynchronous, even with Wait command to wait for synchronization, data loss may still occur after failover, see [documentation](https://redis.io/topics/replication) | Yes | Depends on whether data is lost |   |
| Redis Cluster | Same as above | Yes | Same as above |   |
| Snowflake | No. (ID duplication may occur in case of clock backtracking; external storage is required; or declare the need to turn off NTP or use reliable NTP to prevent backtracking) | Yes | No |   | Good |
| Leaf Snowflake | Yes | Yes | No |     | Good |
| Leaf Segment | Yes | Yes | No |     |
| Deploy only one Leaf server for Leaf Segment | Yes | Yes | Yes | There is a risk of single point of failure |
| ZooKeeper | Yes | Yes | Yes |  |
| etcd | Yes | Yes | Yes |  |
| MySQL Single Database Single Table | Yes | Yes | Yes | There is a risk of single point of failure |

## 3. grpc API Design
### 3.1. Proto Definition

```protobuf
// Sequencer API
rpc GetNextId(GetNextIdRequest) returns (GetNextIdResponse) {}

message GetNextIdRequest {
  string store_name = 1; // The name of the store
  string key = 2; // The identifier of a sequencer

  SequencerOptions options = 3; // Configures the requirements for incremental and uniqueness guarantee
  map<string, string> metadata = 4; // The metadata which will be sent to the component
}

// SequencerOptions configures requirements for incremental and uniqueness guarantee
message SequencerOptions {
  enum AutoIncrement {
    // WEAK means a "best effort" incrementing service.But there is no strict guarantee   
    WEAK = 0;
    // STRONG means a strict guarantee of global monotonically increasing
    STRONG = 1;
  }

  AutoIncrement increment = 1; // Declares the user's requirement for incrementality
}

message GetNextIdResponse {
  int64 next_id = 1; // The next id generated by the sequencer
}
```

Explanation:

There is only one interface, GetNextId, which requires the key as a namespace (e.g. the name of an order table, "order_table"). The sequencer ensures that the generated ids are unique and incremental within that namespace.

SequencerOptions.AutoIncrement is used to declare the user's requirement for incrementality, whether it is weakly incremental (WEAK) or requires strict global incrementality (STRONG).

Q: Will Layotto help users to customize and splice ID on demand?

A: The Layotto API and runtime will not handle this. It's up to the SDK or the user to handle it, or a special component can implement this feature.

Q: Should the return type be a string or int64?

If the return type is a string, and the user uses an implementation that returns int64, the conversion process from string to int64 in the user's code may cause errors when migrating to other components.

If the return type is int64, the component cannot help the user with some customized ID splicing.

For portability, int64 is chosen. The splicing of IDs is done in the SDK.

Q: How to handle int64 overflow?

Not considering it at the moment.

### 3.2. Controversy over uniqueness
The SequencerOptions.Uniqueness enumeration was originally defined in the API, where WEAK represents "try to ensure global uniqueness, but there is a small probability of duplication," requiring the business code to be prepared for ID duplication and retries if the ID is written to the database. STRONG represents strict global uniqueness, and the user code does not consider ID duplication and retry issues.

- The reason for defining this enumeration (benefits)

If strict uniqueness is required, the component implementation will be heavier. For example, the disk write strategy commonly used in single-machine Redis is not feasible and may cause data loss and duplicate ID generation after a crash and restart. For example, directly writing a snowflake algorithm in the sidecar is not feasible because there may be clock rollback issues (NTP clock synchronization, leap seconds, etc.).

- The disadvantages of defining this enumeration

Brings more understanding costs to the user.

- Conclusion

There is controversy, and this enumeration is not added in this issue. The default result must ensure global uniqueness (STRONG).

## 4. Component API

```go
package sequencer

type Store interface {
	// Init this component.
	//
	// The number 'BiggerThan' means that the id generated by this component must be bigger than this number.
	//
	// If the component find that currently the storage can't guarantee this,
	// it can do some initialization like inserting a new id equal to or bigger than this 'BiggerThan' into the storage,
	// or just return an error
	Init(config Configuration) error

	GetNextId(*GetNextIdRequest) (*GetNextIdResponse, error)

	// GetSegment returns a range of id.
	// 'support' indicates whether this method is supported by the component.
	// Layotto runtime will cache the result if this method is supported.
	GetSegment(*GetSegmentRequest) (support bool, result *GetSegmentResponse, err error)
}

type GetNextIdRequest struct {
	Key      string
	Options  SequencerOptions
	Metadata map[string]string
}

type SequencerOptions struct {
	AutoIncrement AutoIncrementOption
}

type AutoIncrementOption string

const (
	WEAK   AutoIncrementOption = "weak"
	STRONG AutoIncrementOption = "strong"
)

type GetNextIdResponse struct {
	NextId int64
}

type GetSegmentRequest struct {
	Size     int
	Key      string
	Options  SequencerOptions
	Metadata map[string]string
}

type GetSegmentResponse struct {
	Segment []int64
}

type Configuration struct {
	BiggerThan map[string]int64
	Properties map[string]string
}
```

**Q: What is the BiggerThan field?**

The requirement is that all IDs generated by the component must be greater than "BiggerThan".

This configuration option is designed to facilitate portability for users. For example, if the system originally used MySQL for ID generation and the IDs have already been generated up to 1000, and later migrated to PostgreSQL, the BiggerThan field needs to be configured as 1000. This way, when the PostgreSQL component is initialized, it will be set to force IDs to be above 1000, or if the IDs cannot meet the requirements, an error will be reported when starting up.

**Q: Why is BiggerThan a map?**

Because each key may have its own BiggerThan value.

For example, if app1 originally did sharding and used a certain ID generation service to generate IDs for the order table and the product table, the order table ID reached 1000 and the product table ID reached 2000.

Later, app1 wants to switch to a different storage for the sequencer, so they need to declare that the order table ID is above 1000 and the product table ID is above 2000.

Another example is the design of Leaf, where each biz_tag corresponds to a max_id (which is equivalent to our BiggerThan).

![leaf_max_id.png](../../../img/sequencer/design/leaf_max_id.png)

**Q: Should caching be implemented at the runtime layer?**

If caching is done at the runtime layer, the component needs to implement the following method:

```go
GetSegment(*GetSegmentRequest) (support bool, result *GetSegmentResponse, err error)
```

The interface can be defined first, and the component can implement it later when there is a performance requirement.

## References
[Designing Distributed Unique ID Generation](https://www.jianshu.com/p/fb9478687e55)

[Discussing Distributed ID Generation Methods](https://www.w3cschool.cn/architectroad/architectroad-distributed-id.html)

[Leaf - Meituan-Dianping's Distributed ID Generation System](https://tech.meituan.com/2017/04/21/mt-leaf.html)